{"ast":null,"code":"function walk(ast, {\n  enter,\n  leave\n}) {\n  return visit(ast, null, enter, leave);\n}\n\nlet should_skip = false;\nlet should_remove = false;\nlet replacement = null;\nconst context = {\n  skip: () => should_skip = true,\n  remove: () => should_remove = true,\n  replace: node => replacement = node\n};\nconst childKeys = {};\n\nfunction replace(parent, prop, index, node) {\n  if (parent) {\n    if (index !== null) {\n      parent[prop][index] = node;\n    } else {\n      parent[prop] = node;\n    }\n  }\n}\n\nfunction remove(parent, prop, index) {\n  if (parent) {\n    if (index !== null) {\n      parent[prop].splice(index, 1);\n    } else {\n      delete parent[prop];\n    }\n  }\n}\n\nfunction visit(node, parent, enter, leave, prop, index) {\n  if (node) {\n    if (enter) {\n      const _should_skip = should_skip;\n      const _should_remove = should_remove;\n      const _replacement = replacement;\n      should_skip = false;\n      should_remove = false;\n      replacement = null;\n      enter.call(context, node, parent, prop, index);\n\n      if (replacement) {\n        node = replacement;\n        replace(parent, prop, index, node);\n      }\n\n      if (should_remove) {\n        remove(parent, prop, index);\n      }\n\n      const skipped = should_skip;\n      const removed = should_remove;\n      should_skip = _should_skip;\n      should_remove = _should_remove;\n      replacement = _replacement;\n      if (skipped) return node;\n      if (removed) return null;\n    }\n\n    const keys = node.type && childKeys[node.type] || (childKeys[node.type] = Object.keys(node).filter(key => typeof node[key] === 'object'));\n\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      const value = node[key];\n\n      if (Array.isArray(value)) {\n        for (let j = 0, k = 0; j < value.length; j += 1, k += 1) {\n          if (value[j] && value[j].type) {\n            if (!visit(value[j], node, enter, leave, key, k)) {\n              // removed\n              j--;\n            }\n          }\n        }\n      } else if (value && value.type) {\n        visit(value, node, enter, leave, key, null);\n      }\n    }\n\n    if (leave) {\n      const _replacement = replacement;\n      const _should_remove = should_remove;\n      replacement = null;\n      should_remove = false;\n      leave.call(context, node, parent, prop, index);\n\n      if (replacement) {\n        node = replacement;\n        replace(parent, prop, index, node);\n      }\n\n      if (should_remove) {\n        remove(parent, prop, index);\n      }\n\n      const removed = should_remove;\n      replacement = _replacement;\n      should_remove = _should_remove;\n      if (removed) return null;\n    }\n  }\n\n  return node;\n}\n\nexport { walk, childKeys };","map":{"version":3,"sources":["/home/fabse/Website/website/node_modules/estree-walker/src/estree-walker.js"],"names":["walk","ast","enter","leave","visit","should_skip","should_remove","replacement","context","skip","remove","replace","node","childKeys","parent","prop","index","splice","_should_skip","_should_remove","_replacement","call","skipped","removed","keys","type","Object","filter","key","i","length","value","Array","isArray","j","k"],"mappings":"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","sourcesContent":["function walk(ast, { enter, leave }) {\n\treturn visit(ast, null, enter, leave);\n}\n\nlet should_skip = false;\nlet should_remove = false;\nlet replacement = null;\nconst context = {\n\tskip: () => should_skip = true,\n\tremove: () => should_remove = true,\n\treplace: (node) => replacement = node\n};\n\nconst childKeys = {};\n\nfunction replace(parent, prop, index, node) {\n\tif (parent) {\n\t\tif (index !== null) {\n\t\t\tparent[prop][index] = node;\n\t\t} else {\n\t\t\tparent[prop] = node;\n\t\t}\n\t}\n}\n\nfunction remove(parent, prop, index) {\n\tif (parent) {\n\t\tif (index !== null) {\n\t\t\tparent[prop].splice(index, 1);\n\t\t} else {\n\t\t\tdelete parent[prop];\n\t\t}\n\t}\n}\n\nfunction visit(\n\tnode,\n\tparent,\n\tenter,\n\tleave,\n\tprop,\n\tindex\n) {\n\tif (node) {\n\t\tif (enter) {\n\t\t\tconst _should_skip = should_skip;\n\t\t\tconst _should_remove = should_remove;\n\t\t\tconst _replacement = replacement;\n\t\t\tshould_skip = false;\n\t\t\tshould_remove = false;\n\t\t\treplacement = null;\n\n\t\t\tenter.call(context, node, parent, prop, index);\n\n\t\t\tif (replacement) {\n\t\t\t\tnode = replacement;\n\t\t\t\treplace(parent, prop, index, node);\n\t\t\t}\n\n\t\t\tif (should_remove) {\n\t\t\t\tremove(parent, prop, index);\n\t\t\t}\n\n\t\t\tconst skipped = should_skip;\n\t\t\tconst removed = should_remove;\n\n\t\t\tshould_skip = _should_skip;\n\t\t\tshould_remove = _should_remove;\n\t\t\treplacement = _replacement;\n\n\t\t\tif (skipped) return node;\n\t\t\tif (removed) return null;\n\t\t}\n\n\t\tconst keys = node.type && childKeys[node.type] || (\n\t\t\tchildKeys[node.type] = Object.keys(node).filter(key => typeof (node )[key] === 'object')\n\t\t);\n\n\t\tfor (let i = 0; i < keys.length; i += 1) {\n\t\t\tconst key = keys[i];\n\t\t\tconst value = (node )[key];\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (let j = 0, k = 0; j < value.length; j += 1, k += 1) {\n\t\t\t\t\tif (value[j] && value[j].type) {\n\t\t\t\t\t\tif (!visit(value[j], node, enter, leave, key, k)) {\n\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (value && value.type) {\n\t\t\t\tvisit(value, node, enter, leave, key, null);\n\t\t\t}\n\t\t}\n\n\t\tif (leave) {\n\t\t\tconst _replacement = replacement;\n\t\t\tconst _should_remove = should_remove;\n\t\t\treplacement = null;\n\t\t\tshould_remove = false;\n\n\t\t\tleave.call(context, node, parent, prop, index);\n\n\t\t\tif (replacement) {\n\t\t\t\tnode = replacement;\n\t\t\t\treplace(parent, prop, index, node);\n\t\t\t}\n\n\t\t\tif (should_remove) {\n\t\t\t\tremove(parent, prop, index);\n\t\t\t}\n\n\t\t\tconst removed = should_remove;\n\t\t\t\n\t\t\treplacement = _replacement;\n\t\t\tshould_remove = _should_remove;\n\n\t\t\tif (removed) return null;\n\t\t}\n\t}\n\n\treturn node;\n}\n\nexport { walk, childKeys };\n"]},"metadata":{},"sourceType":"module"}